/**
 * @module wrapped-secrets-manager-client
 */

// npm imports
import AWSXray from 'aws-xray-sdk';
import smClient from '@aws-sdk/client-secrets-manager';
const { SecretsManager } = smClient;

import _ from 'lodash';

const defaultClientConfig = { region: 'us-east-1' };

/**
 * Wraps an AWS Secrets Manager client to provide standard logging & services.
 */
export class WrappedSecretsManagerClient {
  #client;
  #logger;

  /**
   * WrappedSqsClient constructor.
   *
   * @param {object} [options] - Options.
   * @param {object} [options.logger] - Logger instance (default is {@link https://nodejs.org/api/console.html#class-console global console object}). Must have info, error & debug methods
   * @param {boolean} [options.logInternals] - Log AWS client internals (default is false).
   * @param {object} [options.config] - {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-secrets-manager/interfaces/secretsmanagerclientconfig.html SecretsManagerClientConfig}.
   */
  constructor({
    config = defaultClientConfig,
    logger = console,
    logInternals = false,
  } = {}) {
    // Validate options.
    if (!logger.info || !logger.error || !logger.debug)
      throw new Error('logger must have info, error & debug methods');

    // Set state.
    this.#logger = logger;
    this.#client = AWSXray.captureAWSv3Client(
      new SecretsManager({
        ..._.omit(config, 'logger'),
        ...(logInternals ? { logger } : {}),
      })
    );
  }

  /**
   * @typedef {object} CreateSecretResponse
   * @property {string} arn - The Amazon Resource Name (ARN) of the secret.
   * @property {string} name - The friendly name of the secret.
   * @property {string} replicationStatus - The status of replication for the secret.
   * @property {string} versionId - The unique identifier of the version of the secret that was created.
   */

  /**
   * Create a secret.
   *
   * @param {object} options - Options.
   * @param {string} [options.description] - A user-provided description of the secret.
   * @param {boolean} [options.forceOverwriteReplicaSecret] - Specifies whether to overwrite a secret with the same name in the destination Region.
   * @param {string} options.name - Specifies the friendly name of the new secret. The secret name must be ASCII letters, digits, or the following characters : /_+=.@-
   * @param {string|object} options.value - Specifies the value of the secret.
   * @param {string} [options.versionId] - A unique identifier for the request. If you repeat the request with the same client request token, but change other parameters, AWS CloudFormation returns an error, indicating that the request is not idempotent. Generated by AWS if not submitted.
   * @return {Promise<CreateSecretResponse>} Response object.
   */
  async createSecret({
    description,
    forceOverwriteReplicaSecret,
    name,
    value,
    versionId,
  }) {
    // Validate options.
    if (_.isNil(name)) throw new Error('name is required');
    if (_.isNil(value)) throw new Error('value is required');

    // Send command.
    const params = {
      ...(_.isNil(versionId) ? {} : { ClientRequestToken: versionId }),
      ...(_.isNil(description) ? {} : { Description: description }),
      ...(_.isNil(forceOverwriteReplicaSecret)
        ? {}
        : { ForceOverwriteReplicaSecret: forceOverwriteReplicaSecret }),
      Name: name,
      SecretString: JSON.stringify(value),
    };
    this.#logger.debug(`Creating secret...`, params);

    // Return response.
    const response = await this.#client.createSecret(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret created.`, response);
    return {
      arn: response.ARN,
      name: response.Name,
      replicationStatus: response.ReplicationStatus,
      versionId: response.VersionId,
    };
  }

  /**
   * @typedef {object} DeleteSecretResponse
   * @property {string} arn - The ARN of the secret that is scheduled for deletion.
   * @property {Date} deletionDate - The date and time after which this secret Secrets Manager can permanently delete this secret, and it can no longer be restored. This value is the date and time of the delete request plus the number of days in RecoveryWindowInDays.
   * @property {string} name - The friendly name of the secret that is scheduled for deletion.
   */

  /**
   * Delete a secret.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret to delete.
   * @param {string} [options.recoveryWindowInDays] - Specifies the number of days that AWS CloudFormation waits before deleting the secret permanently. You can specify a minimum value of 7 to a maximum value of 30 days. The default value is 30.
   * @param {string} [options.forceDeleteWithoutRecovery] - Specifies whether to delete the secret without any recovery window.
   * @return {Promise<DeleteSecretResponse>} Response object.
   */
  async deleteSecret({
    secretId,
    recoveryWindowInDays,
    forceDeleteWithoutRecovery,
  }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');
    if (!_.isNil(recoveryWindowInDays) && !_.isNil(forceDeleteWithoutRecovery))
      throw new Error(
        'recoveryWindowInDays & forceDeleteWithoutRecovery are mutually exclusive'
      );

    // Send command.
    const params = {
      SecretId: secretId,
      ...(_.isNil(recoveryWindowInDays)
        ? {}
        : { RecoveryWindowInDays: recoveryWindowInDays }),
      ...(_.isNil(forceDeleteWithoutRecovery)
        ? {}
        : { ForceDeleteWithoutRecovery: forceDeleteWithoutRecovery }),
    };
    this.#logger.debug(`Deleting secret...`, params);

    // Return response.
    const response = await this.#client.deleteSecret(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret deleted.`, response);
    return {
      arn: response.ARN,
      deletionDate: response.DeletionDate,
      name: response.Name,
    };
  }

  /**
   * Describe a secret.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret to describe.
   * @return {Promise<object>} Response object (see {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-secrets-manager/interfaces/describesecretcommandoutput.html DescribeSecretCommandOutput}).
   */
  async describeSecret({ secretId }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');

    // Send command.
    const params = {
      SecretId: secretId,
    };
    this.#logger.debug(`Describing secret...`, params);

    // Return response.
    const response = await this.#client.describeSecret(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret details:`, response);
    return response;
  }

  /**
   * @typedef {object} GetSecretValueResponse
   * @property {string} arn - The ARN of the secret.
   * @property {Date} createdDate - The date and time that this version of the secret was created.
   * @property {string} name - The friendly name of the secret.
   * @property {string|object} value - The secret value.
   * @property {string} versionId - The unique identifier of this version of the secret.
   */

  /**
   * Get a secret value.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret.
   * @param {string} [options.versionId] - The unique identifier of the version of the secret that you want to retrieve.
   * @return {Promise<GetSecretValueResponse>} Response object.
   */
  async getSecretValue({ secretId, versionId }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');

    // Send command.
    const params = {
      SecretId: secretId,
      ...(_.isNil(versionId) ? {} : { VersionId: versionId }),
    };
    this.#logger.debug(`Getting secret value...`, params);

    // Return response.
    const response = await this.#client.getSecretValue(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret value retrieved.`, response);

    // Extract JSON if possible.
    try {
      var value = JSON.parse(response.SecretString);
    } catch {
      value = response.SecretString;
    }

    return {
      arn: response.ARN,
      createdDate: response.CreatedDate,
      name: response.Name,
      value,
      versionId: response.VersionId,
    };
  }

  /**
   * @typedef {object} PutSecretValueResponse
   * @property {string} arn - The Amazon Resource Name (ARN) of the secret.
   * @property {string} name - The friendly name of the secret.
   * @property {string} versionId - The unique identifier of the version of the secret.
   */

  /**
   * Put a secret value.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret.
   * @param {string|object} options.value - Specifies the value of the secret.
   * @param {string} [options.versionId] - A unique identifier for the request. If you repeat the request with the same client request token, but change other parameters, AWS CloudFormation returns an error, indicating that the request is not idempotent. Generated by AWS if not submitted.
   * @return {Promise<PutSecretValueResponse>} Response object.
   */
  async putSecretValue({ secretId, value, versionId }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');
    if (_.isNil(value)) throw new Error('value is required');

    // Send command.
    const params = {
      ...(_.isNil(versionId) ? {} : { ClientRequestToken: versionId }),
      SecretId: secretId,
      SecretString: JSON.stringify(value),
    };
    this.#logger.debug(`Putting secret value...`, params);

    // Return response.
    const response = await this.#client.putSecretValue(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Put secret value.`, response);
    return {
      arn: response.ARN,
      name: response.Name,
      versionId: response.VersionId,
    };
  }
}
