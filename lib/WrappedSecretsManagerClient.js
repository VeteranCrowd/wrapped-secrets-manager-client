/**
 * @module wrapped-secrets-manager-client
 */

// npm imports
import smClient from '@aws-sdk/client-secrets-manager';
const { SecretsManager } = smClient;

import _ from 'lodash';

const defaultClientConfig = { region: 'us-east-1' };

/**
 * Wraps an AWS Secrets Manager client to provide standard logging & services.
 */
export class WrappedSecretsManagerClient {
  #client;
  #logger;

  /**
   * WrappedSqsClient constructor.
   *
   * @param {object} [options] - Options.
   * @param {object} [options.logger] - Logger instance (default is {@link https://nodejs.org/api/console.html#class-console global console object}). Must have info, error & debug methods
   * @param {boolean} [options.logInternals] - Log AWS client internals (default is false).
   * @param {object} [options.config] - {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-secrets-manager/interfaces/secretsmanagerclientconfig.html SecretsManagerClientConfig}.
   */
  constructor({
    config = defaultClientConfig,
    logger = console,
    logInternals = false,
  } = {}) {
    // Validate options.
    if (!logger.info || !logger.error || !logger.debug)
      throw new Error('logger must have info, error & debug methods');

    // Set state.
    this.#logger = logger;
    this.#client = new SecretsManager({
      ..._.omit(config, 'logger'),
      ...(logInternals ? { logger } : {}),
    });
  }

  /**
   * Create a secret.
   *
   * @param {object} options - Options.
   * @param {string} [options.description] - A user-provided description of the secret.
   * @param {boolean} [options.forceOverwriteReplicaSecret] - Specifies whether to overwrite a secret with the same name in the destination Region.
   * @param {string} options.name - Specifies the friendly name of the new secret. The secret name must be ASCII letters, digits, or the following characters : /_+=.@-
   * @param {string} options.value - Specifies the value of the secret.
   * @param {string} [options.versionId] - A unique identifier for the request. If you repeat the request with the same client request token, but change other parameters, AWS CloudFormation returns an error, indicating that the request is not idempotent. Generated by AWS if not submitted.
   * @return {object} Response object.
   */
  async createSecret({
    description,
    forceOverwriteReplicaSecret,
    name,
    value,
    versionId,
  }) {
    // Validate options.
    if (_.isNil(name)) throw new Error('name is required');
    if (_.isNil(value)) throw new Error('value is required');

    // Send command.
    const params = {
      ...(_.isNil(versionId) ? {} : { ClientRequestToken: versionId }),
      ...(_.isNil(description) ? {} : { Description: description }),
      ...(_.isNil(forceOverwriteReplicaSecret)
        ? {}
        : { ForceOverwriteReplicaSecret: forceOverwriteReplicaSecret }),
      Name: name,
      SecretString: value,
    };
    this.#logger.debug(`Creating secret...`, params);

    // Return response.
    const response = await this.#client.createSecret(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret created.`, response);
    return {
      arn: response.ARN,
      name: response.Name,
      replicationStatus: response.ReplicationStatus,
      versionId: response.VersionId,
    };
  }

  /**
   * Delete a secret.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret to delete.
   * @param {string} [options.recoveryWindowInDays] - Specifies the number of days that AWS CloudFormation waits before deleting the secret permanently. You can specify a minimum value of 7 to a maximum value of 30 days. The default value is 30.
   * @param {string} [options.forceDeleteWithoutRecovery] - Specifies whether to delete the secret without any recovery window.
   * @return {object} Response object.
   */
  async deleteSecret({
    secretId,
    recoveryWindowInDays,
    forceDeleteWithoutRecovery,
  }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');
    if (!_.isNil(recoveryWindowInDays) && !_.isNil(forceDeleteWithoutRecovery))
      throw new Error(
        'recoveryWindowInDays & forceDeleteWithoutRecovery are mutually exclusive'
      );

    // Send command.
    const params = {
      SecretId: secretId,
      ...(_.isNil(recoveryWindowInDays)
        ? {}
        : { RecoveryWindowInDays: recoveryWindowInDays }),
      ...(_.isNil(forceDeleteWithoutRecovery)
        ? {}
        : { ForceDeleteWithoutRecovery: forceDeleteWithoutRecovery }),
    };
    this.#logger.debug(`Deleting secret...`, params);

    // Return response.
    const response = await this.#client.deleteSecret(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret deleted.`, response);
    return {
      arn: response.ARN,
      deletionDate: response.DeletionDate,
      name: response.Name,
    };
  }

  /**
   * Get a secret value.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret.
   * @param {string} [options.versionId] - The unique identifier of the version of the secret that you want to retrieve.
   * @return {object} Response object.
   */
  async getSecretValue({ secretId, versionId }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');

    // Send command.
    const params = {
      SecretId: secretId,
      ...(_.isNil(versionId) ? {} : { VersionId: versionId }),
    };
    this.#logger.debug(`Getting secret value...`, params);

    // Return response.
    const response = await this.#client.getSecretValue(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Secret value retrieved.`, response);
    return {
      arn: response.ARN,
      createdDate: response.CreatedDate,
      name: response.Name,
      value: response.SecretString,
      versionId: response.VersionId,
    };
  }

  /**
   * Put a secret value.
   *
   * @param {object} options - Options.
   * @param {string} options.secretId - The ARN or name of the secret.
   * @param {string} options.value - Specifies the value of the secret.
   * @param {string} [options.versionId] - A unique identifier for the request. If you repeat the request with the same client request token, but change other parameters, AWS CloudFormation returns an error, indicating that the request is not idempotent. Generated by AWS if not submitted.
   * @return {object} Response object.
   */
  async putSecretValue({ secretId, value, versionId }) {
    // Validate options.
    if (_.isNil(secretId)) throw new Error('secretId is required');
    if (_.isNil(value)) throw new Error('value is required');

    // Send command.
    const params = {
      ...(_.isNil(versionId) ? {} : { ClientRequestToken: versionId }),
      SecretId: secretId,
      SecretString: value,
    };
    this.#logger.debug(`Putting secret value...`, params);

    // Return response.
    const response = await this.#client.putSecretValue(params);
    if (response.$metadata.httpStatusCode !== 200)
      throw new Error(
        `Unexpected status code: ${response.$metadata.httpStatusCode}`
      );
    this.#logger.debug(`Put secret value.`, response);
    return {
      arn: response.ARN,
      name: response.Name,
      versionId: response.VersionId,
    };
  }
}
